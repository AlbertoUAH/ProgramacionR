---
title: "Práctica Programación R"
author: "Fernández Hernádez Alberto"
date: "26/11/2020"
output:
  pdf_document: default
  html_document:
    df_print: paged
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

__NOTA__: salvo determinados apartados, la solución a cada uno de los ejercicios se ha llevado a cabo por medio de funciones definidas, integrando el código en una misma estructura.

## Pregunta 1. Un boleto del sorteo de la ONCE consta de dos partes, la primera es un número de 4 dígitos y la segunda es un número de tres dígitos que forman la serie del boleto. 

Aquí consideramos sólo el número, por ejemplo, 0209. Se pide:

### a) Genera todos los números que entran en el sorteo de la ONCE y mostrarlos con los cuatro dígitos.

Para generar todos los posibles números de cuatro dígitos, debemos pensar en todas las posibilidades de combinación. Dado que cada casilla puede valer un número comprendido entre 0 y 9, pudiendo repetirse en más de una ocasión, nos encontramos ante una __variación con repetición__. Por tanto, el número de posibles combinaciones es de:

$$
\begin{aligned}
10 * 10 * 10 * 10 = 10^4 = 10000
\end{aligned}
$$

Considerando lo anterior, creamos una función denominada __generar_boletos__, cuyo único parámetro será el número de dígitos que forman la serie. En primer lugar, dado que cada número se puede repetir num_digitos veces (una por cada posición), repetimos la lista de posibles números (0-9) tantas veces como dígitos tenga el número. Finalmente, mediante la función _expand.grid_ se genera un DataFrame con todas las posibles combinaciones a partir del vector anterior (de cara al apartado b):

```{r funcion generar_boletos}
generar_boletos <- function(num.digitos) {
  numeros <- seq(0,9)
  lista.combinaciones <- rep(list(numeros), num.digitos)
  expand.grid(lista.combinaciones)
}
# Prueba
df.combinaciones.sorteo <- generar_boletos(4)
```

Una vez ejecutada la función, echemos un primer vistazo al DataFrame:

```{r prueba generar_boletos}
head(df.combinaciones.sorteo, 5)
tail(df.combinaciones.sorteo, 5)

# Comprobamos que el numero de filas es 10000
nrow(df.combinaciones.sorteo)
```

Como podemos comprobar, el número de filas del DataFrame coincide con el número de posibles combinaciones (10000). Por otro lado, si comprobamos cuántas filas hay únicas (mediante la función _unique_, vemos que también coincide con el total de filas):

```{r numero de filas unicas}
nrow(unique(df.combinaciones.sorteo))
```

Por último, si deseamos recuperar el total de combinaciones con los cuatro dígitos concatenados, mediante un _apply_ aplicamos, a cada fila del DataFrame, la función _paste_, concatenando cada fila en una única cadena:

```{r vector_combinaciones}
vector.combinaciones <- apply(df.combinaciones.sorteo, 1, paste, collapse = "")
# Mostramos las primeras 50 combinaciones
head(vector.combinaciones, 50)
```

### b) ¿Cuál es la suma de los números de un boleto que más se repite?
En primer lugar, para calcular la suma de los dígitos, y dado que se encuentran almacenados en un DataFrame, utilizaremos nuevamente la función _apply_, aplicando a nivel de fila la suma de todas sus columnas:

```{r suma columnas combinaciones}
suma.combinaciones <- apply(df.combinaciones.sorteo, 1, sum)

# Ejemplo de salida
suma.combinaciones[1:20]
```

Por desgracia, R no dispone de una función que permita calcular la moda, por lo que habrá que diseñarla desde cero, pasando como parámetro el vector anterior con las sumas de cada combinación. Desde esta función creamos, en primer lugar, una tabla con las frecuencias de aparición de cada suma, empleando la función _table_. A continuación, obtenemos el/los índices con la/s suma/s de mayor frecuencia de aparición ( _max_ ):

```{r funcion moda}
moda <- function(vector.suma) {
  vector.suma.frecuencias <- table(vector.suma)
  as.numeric(names(vector.suma.frecuencias)[vector.suma.frecuencias == 
                  max(vector.suma.frecuencias)])
}
```

Una vez definida la función, realizamos la correspondiente prueba:

```{r prueba funcion moda}
# Prueba funcion moda
cat("La suma de los numeros que mas se repite es ", moda(suma.combinaciones))
```

Esto último es posible comprobarlo mediante una pequeña tabla dinámica en Excel, contando el número de apariciones en _suma.combinaciones_ :

![Salida tabla dinámica Excel](salida_excel.png)

## Pregunta 2: En la carpeta covid_19 hay una serie de archivos sobre el COVID-19 en España. Se pide:

### a) Leer los archivos "datos_provincias.csv", "CodProv.txt" y "CodCCAA.dat". Añade el código de la comunidad autónoma al fichero "datos_provincias.csv" (no manualmente).

En primer lugar, para leer cada archivo utilizamos la función _read.table_ cuyos parámetros serán la ruta del fichero, el separador de cada columna (dado que los archivos emplean diferentes separadores como la coma o un tabulador), así como la cabecera (el cual debe estar a TRUE en todos los casos, ya que todos los archivos presentes contienen cabecera). Cabe remarcar el parámetro _na.strings_ en _datos_provincias.csv_, ya que la provincia Navarra está denotada como NA, por lo que R lo interpreta como _Not Available_ (vacío). Para evitarlo, indicamos que los campos _Not Available_ corresponden con cadenas vacías en lugar de NA, literalmente:

``` {r leer_fichero}
# Comunidades Autonomas
cod.ccaa <- read.table("CodCCAA.csv", sep = "\t", header = TRUE)
head(cod.ccaa)
#Dimensiones (Filas x Columnas)
dim(cod.ccaa)

# Provincias
cod.prov <- read.table("CodProv.txt", sep = ",", header = TRUE)
head(cod.prov)
#Dimensiones (Filas x Columnas)
dim(cod.prov)

# Datos provincias
# na.string = "" => Para no confundir NA (Navarra) con un valor NA
datos.provincias <- read.table("datos_provincias.csv", sep = ",", header = TRUE, 
                               na.strings = "")
head(datos.provincias)
#Dimensiones (Filas x Columnas)
dim(datos.provincias)
```

Una vez leídos los ficheros, debemos añadir el código de comunidad autónoma, situado en _CodCCAA.csv_, al fichero _datos_provincias.csv_, sin tener que hacerlo manualmente. De forma previa, dado que los ficheros _CodCCAA.csv_ y _CodProv.txt_ contienen columnas con tildes, las renombramos:

``` {r renombrar columnas}
colnames(cod.ccaa) <- c("Cod.Comunidad", "Nombre.Comunidad", "Num")
colnames(cod.prov) <- c("Codigo", "Nombre.de.la.subdivision.en.la.ISO1", 
                        "Comunidad.Autonoma")
```

Una vez renombradas dichas columnas, debemos preguntarnos ¿Cómo enlazamos ambos DataFrames? Debemos fijarnos en que el DataFrame _datos.provincias_ tiene como columna el código de cada provincia, mientras que el DataFrame _cod.ccaa_ no presenta ningún campo relacionado con la provincia, sino con las comunidades autónomas. Sin embargo, disponemos de un DataFrame intermedio (como si de una tabla intermedia se tratase en SQL): _cod.prov_, el cual relaciona la comunidad autónoma con la provincia. 

Por tanto, el objetivo será unir (inicialmente) _cod.ccaa_ con _cod.prov_ para finalmente unirlo con _datos.provincias_, no solo de cara al apartado a) sino además para el apartado b), donde pide los datos en función del código de CCAA, por lo que una vez mezcladas las tres tablas pueden servirnos perfectamente para el resto de apartados. Sin embargo, si nos fijamos en el contenido de los DataFrames, tanto el campo Comunidad Autónoma como el código de Provincia presentan diferentes formatos en cada tabla (por ejemplo, el campo Cod.Autonoma en _cod.ccaa_ empieza por las siglas ES- mientras que el campo correspondiente en _cod.prov_ no, y lo mismo ocurre con el código de Provincia). Por tanto, antes de definir cualquier función debemos renombrar dichos campos, añadiendo las siglas ES-:

``` {r renombrar campos CCAA y Provincia}
cod.prov <- transform(cod.prov, Comunidad.Autonoma = 
                        paste("ES-", Comunidad.Autonoma, sep = ""))
datos.provincias <- transform(datos.provincias, provincia_iso = 
                        paste("ES-", provincia_iso, sep = ""))
```

A continuación, definimos una función ( __juntar_tres_dataframes__ ), que presenta como parámetros el vector con los DataFrames a unir, así como la lista de claves con las que unir dichas tablas:

```{r funcion juntar_tres_dataframes}
juntar_tres_dataframes <- function(vector.df, vector.claves) {
  merge(merge(vector.df[1], vector.df[2], by.x = vector.claves[1], 
              by.y = vector.claves[2], all.x = TRUE), vector.df[3], 
              by.x = vector.claves[3], by.y = vector.claves[4], all.x = TRUE)
}
```

Mediante esta función, aplicaremos dos _merge_ sobre el conjunto de DataFrames: uno entre los dos primeros DataFrames del vector pasados como parámetro (utilizando como claves las proporcionadas en _vector.claves_ ), así como un segundo y último _merge_ entre el DataFrame anterior y el tercero situado en _vector.df_. Cabe destacar que el DataFrame _datos.provincias_ contiene información de las Ciudades Autónomas de Ceuta y Melilla, las cuales __no están almacendas en el resto de tablas__, por lo que al realizar ambos _merge_ debemos conservar todas las filas de la tabla izquierda (mediante el parámetro _all.x = TRUE_) de forma que podamos mantener los datos sobre la evolución del COVID-19 en ambas ciudades.

Por tanto, una vez definida la función realizamos la llamada con los parámetros pertinentes, juntando en primer lugar _datos.provincias_ con _cod.prov_ y finalmente _cod.ccaa_ :

```{r prueba juntar_tres_dataframes}
datos.ccaa <- juntar_tres_dataframes(vector.df = list(datos.provincias, cod.prov, cod.ccaa), 
                                     vector.claves = c("provincia_iso", "Codigo", 
                                     "Comunidad.Autonoma", "Cod.Comunidad") 
                                     )

# Comprobemos que el numero de filas equivale al de datos.provincias
nrow(datos.ccaa) == nrow(datos.provincias)

# Consultemos las primeras filas
head(datos.ccaa)
```

Para comprobar que cada Provincia está en su correspondiente Comunidad Autónoma, mediante un _lapply_ recuperamos cada Comunidad Autónoma, mostrando qué provincias tiene asociadas en el DataFrame. Debemos recordar que tanto Ceuta como Melilla presentan el campo Comunidad.Autonoma a NA, por lo que habrá que comprobarlo ( _is.na_ ):

```{r comprobacion juntar_tres_dataframes}
lapply(unique(datos.ccaa[, "Comunidad.Autonoma"]), function(x) {
  if (is.na(x)) {
    vector.provincias <- c(paste0(x, " => "), 
                           unique(datos.ccaa[is.na(datos.ccaa["Comunidad.Autonoma"]), 
                                             "provincia_iso"]))
  }else {
    vector.provincias <- c(paste0(x, " => "), 
                           unique(datos.ccaa[datos.ccaa["Comunidad.Autonoma"] == x & 
                            !is.na(datos.ccaa["Comunidad.Autonoma"]), "provincia_iso"]))
  }
  vector.provincias
})
```

Por tanto, vemos que cada provincia está asociada a su correspondiente comunidad, salvo Ceuta y Melilla (NA). Una vez tengamos el DataFrame generado, lo volcamos al fichero _datos_provincias.csv_, mediante la función _write.csv_, en lugar de _write.table_ ya que existe una función específica que nos permite escribir directamente sobre archivos con extensión .csv:

```
write.csv(datos.ccaa[c("Comunidad.Autonoma", colnames(datos.provincias))], 
          "datos_provincias.csv", row.names = FALSE)
```

### b) Selecciona los datos de la comunidad autónoma que te corresponda.

Para este apartado, ya disponemos del DataFrame con las tablas cruzadas, incluyendo el código de comunidad y el número de casos. Sin embargo, antes de continuar eliminaremos dos columnas redundantes: __Nombre.de.la.subdivision.en.la.ISO1__ y __Nombre.Comunidad__ (columnas 9 y 10, respectivamente) , ya que disponemos de las columnas __Comunidad.Autonoma__ y __provincia_iso__, evitando con ello información redundante:

```{r borrado_columnas_redundantes}
datos.ccaa <- datos.ccaa[, -c(9, 10)]
```

Una vez eliminadas dichas columnas, mediante la función __seleccionar_datos_comunidad__ filtraremos los datos en función del código de comunidad, sumando los dígitos del DNI mod 17 (a través de la función _subset_ ), obteniendo el código con el mismo valor resultante:

```{r seleccionar_datos_comunidad}
seleccionar_datos_comunidad <- function(datos.ccaa, dni) {
  subset(datos.ccaa, Num == (dni %% 17))
}

# Prueba con Castilla y Leon (DNI = 12345678 mod 17 -> 6)
head(seleccionar_datos_comunidad(datos.ccaa, 12345678), 5)

# Prueba con Cantabria (DNI = 54003003 mod 17 -> 4)
datos.filtrado <- seleccionar_datos_comunidad(datos.ccaa, 54003003)
head(datos.filtrado, 5)
```

### c) Realizar un gráfico que muestre adecuadamente la evolución de los casos nuevos. Justifica el gráfico elegido.

__NOTA__: para la realización de este apartado se utilizarán los datos filtrados por el DNI el cual tengo asociado: 54003003, correspondiente con la __Comunidad Autónoma de Cantabria__, aunque también puede emplearse el _dataset_ completo o de cualquier otra comunidad gracias al dinamismo de las funciones.

Para este apartado (y de forma previa a su implementación gráfica), la mejor forma de representación sería __agrupando el número de casos por fecha__, de forma que podamos tener el total de casos diarios. Para ello, y de cara tanto al apartado c) como d), diseñamos una función denominada __agrupar_datos__ que recibe como parámetros el DataFrame a agrupar (datos.ccaa), el campo sobre el que agrupar (clave), así como un vector de columnas a filtrar.

Para ello, mediante la función _by_ agrupamos cada fila por el campo __clave__ (pasado como parámetro), obteniendo sus valores únicos. En el resto de columnas indicadas por parámetro, mediante la función _lapply_ realizaremos el sumatorio por cada una de ellas, concatenando los resultados a través de la función _cbind_, la cual es invocada gracias a la función _do.call_. Una vez obtenida la fila, eliminamos su nombre ( _rownames_ ) ya que por defecto es la primera columna; además de agrupar cada una de ellas en un mismo DataFrame, aplicando la función _rbind_, incluyendo finalmente los nombres de columnas:

```{r agrupar_datos}
agrupar_datos <- function(datos.ccaa, clave, columnas) {
  agrupacion <- by(datos.ccaa, list(datos.ccaa[, clave]), function(fila) {
      data.frame(
          total = unique(fila[, clave]),
          do.call(cbind,
              lapply(columnas, function(columna) sum(fila[, columna]))
      )
    )
  })
  # Eliminamos los indices de fila (por defecto es la primera columna)
  rownames(agrupacion) <- NULL
  df.agrupado <- do.call(rbind, agrupacion)
  colnames(df.agrupado) <- c(clave, columnas)
  df.agrupado
}
```

Una vez definida la función, __agrupamos el número de casos (num_casos) por cada fecha__ :

``` {r prueba agrupar_datos}
# Prueba agrupar_datos
datos.agrupados.fecha <- agrupar_datos(datos.filtrado, "fecha", "num_casos")
# Echamos un primer vistazo a los datos obtenidos
tail(datos.agrupados.fecha)
```

Una vez tengamos los datos agrupados, de cara a facilitar la representación gráfica cambiaremos el tipo de dato al formato fecha ( _factor_ a _Date_ ):

```{r conversion de factor a Date, campo fecha}
datos.agrupados.fecha[, "fecha"] <- as.Date(datos.agrupados.fecha[, "fecha"])

sapply(datos.agrupados.fecha, class)
```

Una vez preprocesado el DataFrame, es momento de realizar su representación gráfica. Lo primero que debemos pensar es qué tipo de gráfico elegir (gráfico de barras, gráfico de líneas...). Una primera opción sería aplicar un gráfico de barras vertical, donde cada barra muestre el número de casos por cada fecha. Esta opción, a simple vista, resultaría ser viable de no ser por un factor: __el elevado número de filas__.

```{r numero de filas}
nrow(datos.agrupados.fecha)
```

Es decir, supondría tener que representar en un mismo eje 237 barras en las que se muestra la distribución del número de casos a lo largo del tiempo, lo que podría dificultar el entendimiento del gráfico. Por ello, una alternativa sería agrupar nuevamente los datos __por meses__, reduciendo con ello el número de barras a representar. Para ello, realizamos una agrupación por cada mes, mediante la función _format_, representando el diagrama de barras empleando la función _barplot_ tal y como se muestra a continuación:

```{r prueba_diagrama_barras}
agrupacion_v2 <- by(datos.agrupados.fecha, list(format(datos.agrupados.fecha[, "fecha"], "%m")),
  function(fila) {
    data.frame(
      mes = unique(format(fila[, "fecha"], "%m")),
      num_casos = unique(sum(fila[, "num_casos"]))
    )
})
agrupacion_v2 <- do.call(rbind, agrupacion_v2)
```
\newpage

```{r prueba_diagrama_barras_2, fig.width=6, fig.height=5, fig.cap="Gráfico de barras con la evolución del número de casos"}
barplot(agrupacion_v2[, "num_casos"], names = agrupacion_v2[, "mes"],
        ylab = "NUMERO DE CASOS", xlab = "MESES", 
        main = "EVOLUCION NUMERO DE CASOS COVID-19")
```

Sin embargo, nos encontramos con un inconveniente: __¿Qué ha ocurrido en los meses de marzo, abril, agosto o septiembre?__. Es decir, la incidencia acumulada ha sido alta, pero ¿Ha sido así durante todo el mes? ¿O ha habido semanas con un mayor repunte? A primera vista, con tan solo nueve barras somos incapaces de comprobarlo, es decir, perdemos información al agrupar. 

Por el contrario, utilizar un gráfico de líneas puede resultar una mayor ventaja, permitiendo mostrar los cambios que sufre una variable __a lo largo del tiempo__, dado que lo que se desea representar es, al fin y al cabo, una serie temporal en el que se muestra una sucesión del número de casos por COVID-19, donde lo que se analiza es su tendencia (ascendente o descendente) entre días o semanas (no solo entre meses). Por el contrario, un gráfico de barras se emplea comunmente para comparar datos con un número limitado de categorías o grupos, sobretodo cuando la muestra no es muy grande.

Por ello, tanto para el apartado c) como d) creamos una función, denominada __imprimir_grafica__, recibiendo como parámetros el conjunto de datos a mostrar, las columnas empleadas para los ejes X e Y, el número de saltos a realizar en el eje X, así como el color del gráfico y un parámetro ( __segmentos__ ) que permite, en caso de estar a TRUE, crear un segmento por cada fecha en el eje, uniéndolo con su correspondiente valor en el gráfico, además de mostrar una tendencia (suavizada) del número de casos:

```{r imprimir_grafica}
imprimir_grafica <- function(datos, eje.x, eje.y, saltos.eje.x, color, segmentos = FALSE) {
  par(mar=c(11,4,4,1), xaxt = "n")
  grafico.lineas <- plot(x = datos[, eje.x], y = datos[, eje.y], type = "l",
                         ylim = range(pretty(c(0, datos[, eje.y]))),
                         main = "EVOLUCION NUMERO DE CASOS COVID-19", 
                         xlab = "", ylab = "NUMERO DE CASOS", font.lab = 2, 
                         col = color, las = 2, lwd = 2)
  par(xaxt = "s")
  sec <- seq(datos[1, eje.x], datos[nrow(datos[eje.x]), eje.x], 
             by = saltos.eje.x)
  
  axis.Date(1, at = sec, format = "%Y-%m-%d", las = 2)
  
  if (segmentos == TRUE) {
    segments(sec, 0, sec, subset(datos, datos[, eje.x] %in% sec)[, eje.y],
             lty = 2)
    points(x = subset(datos, datos[, eje.x] %in% sec), pch = 20)
    lines(smooth.spline(datos[, eje.x],
                        datos[, eje.y]),
          col = rgb(red = 0, green = 0, blue = 1, alpha = 0.7), 
          lwd = 2)
  }
  mtext(text = "FECHA", side = 1, line = 6, font = 2)
}
```

De la función anterior, quisiera destacar algunos detalles relevantes:

1. Para poder apreciar en mayor medida el gráfico resultante, mediante la función _par_ establecemos unos mayores márgenes de representación, además de eliminar temporalmente el eje X. Esto último lo hacemos para que el usuario, por parámetro, pueda elegir el número de divisiones (el número de fechas a mostrar en el eje X) de forma dinámica.

2. Por otro lado, el parámetro _las_ se emplea para modificar la orientación de las etiquetas de los ejes (en horizontal), mientras que el campo _lwd_ modifica el grosor del gráfico.

3. Tras borrar el eje X con la función _par_, mediante la función _axis.Date_ establecemos el eje de abcisas (concretamente en formato fecha), obteniendo una secuencia de fechas en función del parámetro ( _saltos.eje.x_ ).

4. Una vez creado el eje de abcisas y si el usuario lo desea, mediante la función _segments_ establecemos las rectas discontinuas para cada fecha en el eje X, empleando para ello la misma secuencia que con la función _axis.Date_. De este modo, el usuario podrá visualizar con mayor facilidad el número de casos en cada fecha.

5. Mediante la función _points_ marcamos los números de casos anteriores.

6. Mediante la función _smooth.pline_ del paquete _stats_ se crea un gráfico "suavizado" con respecto a los datos originales, con el objetivo de visualizar la tendencia del número de casos a lo largo del gráfico.

7. Por último, mediante la función _mtext_ establecemos el título del eje X.

Una vez definida la función, realizamos la prueba:

\newpage
```{r prueba_imprimir_grafica, fig.width=9, fig.height=8, fig.cap="Gráfica con el número de casos en Cantabria"}
# Prueba imprimir_grafica
imprimir_grafica(datos.agrupados.fecha, "fecha", "num_casos", 14, "red", TRUE)
```

Analizando la evolución del número de casos, podemos observar el elevado pico de contagios producido durante los primeros meses de pandemia, en especial cuando las medidas en Europa (y en concreto España), no eran lo suficientemente estrictas. Tras la declaración del estado de alarma el día 14 de marzo, los efectos del confinamiento se tradujeron en un descenso lento en el número de casos diarios, aunque no constantes, sino que observamos numerosos "repuntes" en el número de casos durante los meses de marzo y abril (algo que no podíamos comprobar con un diagrama de barras). No obstante, con la apertura gradual de fronteras y negocios la curva de contagios comenzó a crecer desde comienzos de verano, aunque de forma menos "apuntalada" , alcanzando en el mes de septiembre valores cercanos a los meses de abril y marzo aunque, al igual que en la "primera ola", con contínuos repuntes en el número de casos.

Cabe destacar, especialmente, la caída en el número de contagios a partir del día 22 de septiembre, lo que puede deberse a una falta de datos por parte de la Comunidad Autónoma, por lo que el _dataset_ puede estar incompleto para dicho día.

### d) Presenta en un único gráfico la evolución de las distintas variables (columnas) por medio de un gráfico de líneas múltiples. Utiliza diferentes colores y añade una leyenda que muestre el origen de cada línea.

Para este apartado, dado que disponemos de una función diseñada en el apartado anterior que permite agrupar las columnas de un DataFrame, llamaremos de nuevo a dicha función agrupando cada columna (casos nuevos, casos por pruebas PCR, casos por pruebas anticuerpos, otras pruebas y pruebas desconocidas) en función de la fecha. De este modo podremos conocer la evolución de cada variable a lo largo del tiempo:

```{r agrupar_datos_multiples_columnas}
casos.por.columnas <- agrupar_datos(datos.filtrado, "fecha", c("num_casos", 
                                   "num_casos_prueba_pcr", 
                                   "num_casos_prueba_test_ac", "num_casos_prueba_otras", 
                                   "num_casos_prueba_desconocida"))
# Modificamos nuevamente el campo fecha (factor -> Date)
casos.por.columnas[, "fecha"] <- as.Date(casos.por.columnas[, "fecha"])

# Mostramos las ultimas seis filas
tail(casos.por.columnas)
```

Una vez agrupado el DataFrame, debemos representar gráficamente cada columna con un color diferente. Para ello, creamos una función denominada __imprimir_multiples_lineas__, que recibe como parámetros tanto el DataFrame a representar gráficamente, los valores del eje X (campo fecha), del eje Y (columnas con el número de casos); además de un vector con la paleta de colores para cada línea y el número de saltos a realizar en el eje X.

En primer lugar, la función recupera la primera de las columnas pasadas como parámetro (num_casos) y establece el mismo gráfico que el del apartado anterior, llamando a la función __imprimir_grafica__ (sin imprimir los segmentos como en el apartado anterior). A continuación, mediante la función _mapply_ por cada pareja (columna, color) se añade una nueva línea al gráfico ( _line_ ), asociando su correspondiente color. Finalmente, por medio de la función _legend_ se muestra la leyenda en el gráfico, situándose en la parte superior:

```{r imprimir_multiples_lineas}
imprimir_multiples_lineas <- function(datos, eje.x, eje.y, paleta, saltos.eje.x) {
  imprimir_grafica(datos, eje.x, eje.y[1], saltos.eje.x, paleta[1])
  
  mapply(FUN = function(x, y) { 
    lines(datos[, eje.x], datos[, x], col = y, lwd = 2)
  }, eje.y, paleta)
  
  eje.y <- lapply(gsub('_', ' ', eje.y), toupper)
  legend(x= "top",  legend = eje.y, fill = paleta, cex = 0.7, text.font = 2, bg = 'white') 
}
```

A continuación, realizamos la correspondiente prueba, mostrando la evolución de cada columna a lo largo del tiempo:

```{r prueba_imprimir_multiples_lineas, fig.width=9, fig.height=8, fig.cap="Gráfica con el número de casos de cada categoría en Cantabria"}
# Prueba imprimir_multiples_lineas
columnas <- c("num_casos", "num_casos_prueba_pcr", "num_casos_prueba_test_ac",
              "num_casos_prueba_otras", "num_casos_prueba_desconocida")
paleta <- c("red", "blue", "orange", "darkgreen", "purple")

imprimir_multiples_lineas(casos.por.columnas, "fecha", columnas, paleta, 14)
```

Analizando la gráfica resultante podemos comprobar cómo desde el comienzo de la pandemia la mayoría de los casos por COVID-19 son diagnosticados por pruebas PCR. Por el contrario, otras pruebas como los Anti-cuerpos, "Otras" o "Desconocida" apenas se emplearon en la Comunidad Autónoma, salvo casos excepcionales.

Para demostrar que cada columna se está mostrando correctamente, realizamos una pequeña prueba a nivel nacional, __con los datos de todas las CCAA__:

\newpage
```{r prueba_imprimir_multiples_lineas_2, fig.width=9, fig.height=8, fig.cap="Gráfica con el número de casos de cada categoría en España"}
casos.por.columnas <- agrupar_datos(datos.ccaa, "fecha", columnas)
casos.por.columnas[, "fecha"] <- as.Date(casos.por.columnas[, "fecha"])

imprimir_multiples_lineas(casos.por.columnas, "fecha", columnas, paleta, 14)
```

## Pregunta 3. Consideramos un fichero de datos en formato SAS de nombre "punt.sas7bdat" que contiene datos sobre alumnos matriculados en diversos cursos.

### a) Importa el fichero de datos y guárdalo en un objeto de nombre punt. Comprueba la estructura del objeto punt. Si es necesario conviértelo en un data frame.

Hasta ahora, hemos trabajado con ficheros de extensiones .txt o separados por comas (.csv). En este apartado, nos encontramos con una nueva extensión: __sas7bdat__. Una posible opción sería leer dicho fichero por medio de las funciones del paquete base como _scan_ o incluso _read.table_ :

```{r, error=TRUE}
read.table("Punt.sas7bdat")
```

Sin embargo, dicha función no permite leer el contenido del archivo. Esto es debido a que el fichero _Punt.sas7bdat_ __NO__ contiene la información en texto plano, por lo que su contenido no es legible a simple vista:

![Contenido del fichero Punt.sas7bdat](formato_fichero.png)

Esto último supone que las funciones base de R no nos permiten leer su contenido. Por ello, __y como único caso excepcional a lo largo de la práctica__, recurriremos a una librería externa denominada [_sas7bdat_ ( __Click para acceder al sitio web de CRAN__ )](https://cran.r-project.org/web/packages/sas7bdat/sas7bdat.pdf) . Para instalar el paquete, empleamos la función _install.packages_. Una vez instalado, debemos importarlo por medio de la función _library_ :

```{r instalacion_paquete_sas7bdat, results = 'hide'}
install.packages("sas7bdat", repos = "http://cran.us.r-project.org")
```

```{r carga_libreria_sas7bdat}
# Una vez instalado, lo cargamos
library(sas7bdat)
# Vemos que aparece, junto con las librerias estandar de R
(.packages())
```

Una vez cargado el paquete, ya podemos utilizar la función _read.sas7bdat_, la cual permite leer un fichero SAS en formato binario de forma más cómoda que las librerías de R base, almacenando su contenido (por defecto en formato DataFrame) en una variable denominada _punt_:

```{r carga Punt.sas7bdat}
punt <- read.sas7bdat("Punt.sas7bdat")

# Comprobamos que se trata, efectivamente, de un DataFrame
class(punt)
# Una vez cargado, echamos un primer vistazo a las filas...
head(punt)
# ... Y a las columnas ...
sapply(punt, class)
```

Analizando las columnas, podemos comprobar cómo los campos de cadenas de caracteres (SEGSOC, ENROLLED, COURSE y TEACHER) se codifican como _factor_.

### b) Obtener una nueva variable overall que de la puntuación media de los cuatro test para cada estudiante suponiendo que el último test se pondera el doble.

Para este apartado creamos nuevamente una función, denominada __calcular_total_puntuacion__, que recibe como parámetros el DataFrame con las puntuaciones, la columna con el identificador del alumno así como un vector con las puntuaciones de cada test. Sobre dicho DataFrame aplicamos la función _cbind_, concatenando las columnas pasadas como parámetro junto con una nueva columna (OVERALL) con la puntuación media de cada alumno. Para su cálculo, mediante la función _apply_ aplicamos la función _mean_ sobre las n - 1 primeras columnas y, con la n-ésima columna, añade su valor multiplicado por dos:

```{r calcular_total_puntuacion}
calcular_total_puntuacion <- function(puntuaciones, id.alumno, columnas.test) {
  cbind(puntuaciones[c(id.alumno, columnas.test)], 
            OVERALL = apply(puntuaciones[columnas.test], 1, function(x) {
              mean(c((x[1:length(x) - 1]), 2*x[length(x)]))
  }))
}
```

Una vez definida la función, realizamos la prueba, almacenando el resultado en una variable denominada _overall_ :

```{r prueba_calcular_total_puntuacion}
overall <- calcular_total_puntuacion(punt, "SEGSOC", c("TEST1", "TEST2", "TEST3", "TEST4"))
overall
```

### c) Formar una nueva variable denominada start compuesta por el mes y día de ENROLLED y por el año corriente y presenta en pantalla las variables SEGSOC, COURSE y start.

De forma similar al apartado b), definimos una función denominada __anadir_columna_fecha__, que recibe como parámetros las puntuaciones en formato DataFrame, la columna compuesta por el día y mes (dia.mes), así como un vector con el resto de columnas a proyectar (en nuestro caso SEGSOC y COURSE). Sobre dicha función aplicamos nuevamente _cbind_, concatenando las columnas anteriores con una nueva, denominada START, formada por el año corriente (mediante la función _format(Sys.Date(), "%Y")_), así como el mes y día del parámetro dia.mes:

```{r anadir_columna_fecha}
anadir_columna_fecha <- function(puntuaciones, dia.mes, columnas) {
  cbind(puntuaciones[columnas], START = apply(puntuaciones[dia.mes], 1, function(x) {
    paste0(format(Sys.Date(), "%Y"), "-", x)
  }))
}
```

Una vez definida la función, realizamos la prueba con las columnas ENROLLED, SEGSOC y COURSE, almacenando el resultado en una variable denominada _start_ :

```{r prueba_anadir_columna_fecha}
start <- anadir_columna_fecha(punt, "ENROLLED", c("SEGSOC", "COURSE"))
start
```

### d) Formar un nuevo data frame de nombre level500 que contenga los estudiantes cuyo curso acaba en 500. Crear dos nuevas variables carácter, una de nombre subject con el código de curso (parte literal) y otra de nombre level con el número del curso (parte numérica).

Para este apartado, la función diseñada (denominada __crear_nuevo_df__) contiene como parámetros el DataFrame con las puntuaciones de cada alumno, el número de curso a filrar, así como la columna donde aplicar el filtro (COURSE).

Inicialmente, debemos recuperar aquellas filas del DataFrame cuyo valor en la columna COURSE acabe en "500". Para ello, mediante la función _grep_ aplicamos una __expresión regular__ a todas las filas del DataFrame, filtrando aquellas que acaben en 500 (para indicarlo mediante una expresión regular, bastaría con concatenar el valor pasado como parámetro junto con el símbolo "$"). Una vez filtradas las filas, mediante la función _transform_ añadimos las dos nuevas columnas. Para ello, mediante la función _gsub_ aplicamos la expresión regular "([A-Za-z]+)([0-9]+)" a la columna COURSE, lo que permite extraer por un lado (SUBJECT) el código de curso, expresión formada por las letras del alfabeto ([A-Za-z]+); así como la columna LEVEL, que contiene la parte numérica del curso ([0-9]+).

Por último, para convertir ambas variables en tipo carácter (en lugar de factor o numérico), a cada nueva columna le aplicamos la función _as.character_ (mediante _lapply_), reestableciendo los números de fila:

```{r crear_nuevo_df}
crear_nuevo_df <- function(puntuaciones, codigo, columna) {
  punt.filtrado <- puntuaciones[grep(paste0(codigo,"$"), puntuaciones[, columna]), ]
  regex <- "([A-Za-z]+)([0-9]+)"
  punt.filtrado <- transform(punt.filtrado, 
                             SUBJECT = gsub(regex, replacement = "\\1" , 
                                            x = punt.filtrado[, columna]),
                             LEVEL = gsub(regex, replacement = "\\2" , 
                                          x = punt.filtrado[, columna])
  )
  punt.filtrado[, c("SUBJECT", "LEVEL")] <- lapply(punt.filtrado[, c("SUBJECT", "LEVEL")], 
                                                   as.character)
  rownames(punt.filtrado) <- NULL
  punt.filtrado
}
```

Una vez definida la función, creamos el nuevo DataFrame ( _level500_ ), filtrando aquellos estudiantes cuyo curso acaba en 500, además de las dos nuevas variables (SUBJECT, LEVEL):

```{r prueba_crear_nuevo_df}
# Prueba crear_nuevo_df
level500 <- crear_nuevo_df(punt, "500", "COURSE")
level500
```

```{r prueba_crear_nuevo_df_tipo_datos}
# Comprobamos el tipo de dato de las nuevas columnas
sapply(level500, class)
```

Como podemos observar en la ejecución anterior, las columnas SUBJECT y LEVEL se codifican como _character_. 

### e) Escribe la información de level500 en un fichero ASCII de nombre "level500.dat".

Finalmente, para volcar el contenido del DataFrame en un fichero (en formato ASCII), bastará con emplear la función _write.table_, tal y como se muestra a continuación, omitiendo los números de fila ( _row.names = FALSE_ ):

```
write.table(level500, file = "level500.dat", row.names = FALSE)
```
![Contenido de level500.dat](level_500.png)

## Pregunta 4. La siguiente tabla representa puntuaciones de sensación de ardor para 16 sujetos en un estudio para probar un nuevo hidrogel. La primera columna da el número del sujeto. Las siguientes columnas dan la puntuación de sensación de ardor (en una escala de 1 a 4) para semanas 1 (S1) a 7 (S7). (La matriz de datos se encuentra en "matriz.R")

Inicialmente, cargamos la matriz en una variable, denominada _puntuaciones.hidrogel_ :

```{r matriz_puntuaciones_hidrogel}
puntuaciones.hidrogel <- structure(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 
                         16, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                         1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
                         1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 1, 1, 1, 1, 1, 3, 
                         2, 1, 1, 1, 1, 1, 1, 2, 1, 4, 1, 1, 1, 1, 1, 2, 2, 1, 1, 1, 1, 
                         2, 3, 3, 1, 2, 1, 1, 1, 1, 1, 3, 4, 1, 1, 1, 2, 3, 4, 3, 1, 2, 
                         1, 1, 4, 1, 1, 4, 4, 1, 1), .Dim = c(16L, 8L))
puntuaciones.hidrogel
```

Cabe destacar que, a diferencia de los apartados anteriores, ya no disponemos de nombres de columnas, por lo que habrá que utilizar índices númericos.

### a) Para la semana $S_7$, calcule el vector $(f_1, 1 - f_1, f_2, 1 - f_2, f_3, 1 - f_3, f_4, 1 - f_4)$ , donde $f_i$ es la frecuencia de la modalidad i (1,2,3,4) observada en la semana $S_7$ sobre los 16 sujetos. (Sugerencia: use las funciones tabulate(), cbind(), t() y as.vector())

En primer lugar, de cara al apartado b), creamos una función denominada __calcular_vector_frecuencias__ que recibe como parámetro la columna directamente con sus puntuaciones, además del número total de puntuaciones (en nuestro caso 4). Inicialmente, mediante la función _tabulate_ obtenemos el número de repeticiones de cada puntuación en la columna pasada como parámetro. A continuación, una vez obtenido el número de repeticiones calculamos la frecuencia __relativa__ de cada uno, dividiéndolo entre la longitud de la columna __puntuaciones__. Por último, mediante la función _rbind_ (equivalente a t(cbind())) unimos los vectores de frecuencias (f, 1 - f), concatenando cada pareja. 

Sin embargo, puede ocurrir que una puntuación no aparezca en la columna (por ejemplo, en las semanas 1 y 3 solo aparece la puntuación 1), por lo que por cada puntuación faltante añadimos las parejas (0,1), es decir, la frecuencia de aparición es 0 y por tanto, 1 - f = 1.

```{r calcular_vector_frecuencias}
calcular_vector_frecuencias <- function(puntuaciones, categorias) {
  frecuencias <- tabulate(puntuaciones) / length(puntuaciones)
  categorias.faltantes <- categorias - length(frecuencias)
  c(as.vector(rbind(frecuencias, 1 - frecuencias)), rep(c(0,1), categorias.faltantes))
}
```

Una vez creada la función, calculamos el vector para la semana $S_7$. Dado que los números de fila ( $N_r$ ) forman parte de la matriz como una columna más, a cada índice habrá que sumarle 1:

```{r prueba_calcular_vector_frecuencias}
# Prueba con la semana 7 (columna 7 + 1)
calcular_vector_frecuencias(puntuaciones.hidrogel[ ,8], 4)
```

Si nos fijamos en la matriz, la puntuación 1 se repite 8 veces (f = 8/16 = 0.5; 1 - f = 0.5). Por otro lado, la puntuación 2 se repite en dos ocasiones (f = 2/16 = 1/8 = 0.125, 1 - f = 0.875); la puntuación 3, por su parte, aparece 2 veces (f = 2/16 = 1/8 = 0.125, 1 - f = 0.875), y finalmente la puntuación 4 aparece en 4 ocasiones (f = 4/16 = 1/4 = 0.250, 1 - f = 0.750). Por tanto, podemos comprobar que las parejas de frecuencias (f, 1 - f) coinciden.

### b) Ahora, use la función apply() para hacer el mismo cálculo para todas las demás semanas. Almacene el resultado en una matriz.

Por medio de la función _apply_ aplicamos la función anterior a cada columna de la matriz, salvo la primera columna, que contiene los números de fila. Una vez aplicada la función, creamos un único vector a través de la función _unlist_ con el que obtener, a continuación, una matriz de 8 filas (parejas de frecuencias (f, 1 - f) x número de posibles puntuaciones = 2 x 4). Para facilitar su lectura, a cada nombre de columna le asignaremos el día de la semana, mientras que a cada fila le asignaremos la frecuencia de cada puntuación:

```{r apply_calcular_vector_frecuencias}
matriz.frecuencias <- matrix(unlist(apply(
        puntuaciones.hidrogel[, -1], 2, calcular_vector_frecuencias, categorias = 4)),
        nrow = 8)

rownames(matriz.frecuencias) <- c("1", "1-f1", "2", "1-f2", "3", "1-f3", "4", "1-f4")
colnames(matriz.frecuencias) <- c("S1", "S2", "S3", 
                                  "S4", "S5", "S6", "S7")

# Comprobamos que se trata, efectivamente, de una matriz
class(matriz.frecuencias)
# Mostramos su contenido
matriz.frecuencias
```

### c) Utilice la función barplot() y el argumento col = c("black", "white") en esta matriz. El gráfico que se obtiene ofrece una descripción general de la evolución de la Sensación de ardor con el tiempo.

Mediante la función _barplot_, mostramos el diagrama de barras además de incluir una leyenda en la parte derecha del gráfico (modificando el margen derecho para no solaparlo):

```{r diagrama_barras, fig.width=6, fig.height=5, fig.cap="Gráfico de barras con la evolución de la sensación de ardor con el tiempo (I)"}
par(xpd = TRUE, mar = par()$mar + c(0,0,0,4))
barplot(matriz.frecuencias, col = c("black", "white"), 
        main = "EVOLUCION SENSACION DE ARDOR CON EL TIEMPO")
legend(x= "topright",  legend = c("FREC. ARDOR", "FREC. SIN ARDOR"), 
       inset = c(-0.3, 0), fill = c("black", "white"), 
       cex = 0.6, text.font = 2, bg = 'white') 
```

A través del gráfico anterior, podemos comprobar como, con el transcurso de las semanas, la sensación de ardor al emplear el hidrogel aumenta, concretamente a partir de la cuarta semana, donde aproximadamente una cuarta parte de los usuarios aumentaron su puntuación a 2 y 3.

### d) Cambie el gráfico anterior para que las barras que representan las frecuencias estén en rojo. Los números de las semanas deben estar en azul y en la parte superior del gráfico en lugar del fondo. Los números de modalidad deben estar a la izquierda, en azul. Agrega un título al gráfico.

Para resolver este apartado creamos una función denominada __mostrar_frecuencias__, que recibe como parámetros, además de la matriz, el ancho de cada conjunto de barras apiladas, así como el espacio entre cada una:

```{r mostrar_frecuencias}
mostrar_frecuencias <- function(matriz, ancho, espacio) {
  par(xpd = TRUE, mar = c(0,4,5,6))
  barplot(matriz.frecuencias, col = c("red", "white"), width = ancho, 
          space = espacio, xaxt = "n", yaxt = "n",
          ylab = "PUNTUACION", cex.lab = 1.25)
  
  pos_inicial <- ancho / 2 + espacio
  longitud <- length(colnames(matriz)) - 1
  v <- Reduce(function(v, x) v + 2 * ancho / 2 + espacio, x=numeric(longitud),  
              init=pos_inicial, accumulate=TRUE)
  axis(side = 3, at = v, colnames(matriz), col.axis = "blue", font = 2, tick = FALSE)
  
  pos_inicial_2 <- ancho / 2
  longitud_2 <- length(row.names(matriz)) / 2 - 1
  w <- Reduce(function(w, x) w + 2 * pos_inicial_2, x=numeric(longitud_2),
              init=pos_inicial_2, accumulate=TRUE)
  axis(side = 2, at = w, row.names(matriz)[seq(1,length(row.names(matriz)),2)], 
       col.axis = "blue", cex = 125, font = 2, tick = FALSE)
  
  title("FRECUENCIAS DE ARDOR DE HIDROGEL - SEMANAS 1 A LA 7", line = 4, cex.main = 1.25)
  legend(x= "topright",  legend = c("FREC. ARDOR", "FREC. SIN ARDOR"), 
         inset = c(-0.2, 0), fill = c("red", "white"), 
         cex = 0.6, text.font = 2, bg = 'white') 
}
```

1. __Las barras que representen las frecuencias deben estar en rojo__. Para que las barras que indican las frecuencias estén en color rojo, al realizar la función _barplot_ modificamos el vector de colores, cambiándose a _("red", "white")_, además de ajustar los márgenes para poder añadir tanto los ejes como la leyenda en el gráfico:

```
par(xpd = TRUE, mar = c(0,4,5,6))
barplot(matriz.frecuencias, col = c("red", "white"), width = ancho, 
        space = espacio, xaxt = "n", yaxt = "n",
        ylab = "PUNTUACION", cex.lab = 1.25)
```

2. __Los números de las semanas deben estar en azul y en la parte superior del gráfico en lugar del fondo__. Si nos fijamos en la función _barplot_ anterior, vemos que tanto el parámetro _xaxt_ como _yaxt_ están a "n", lo que significa que por el momento no se muestran los ejes. Esto es debido a que mediante la función _axis_ que ofrece el paquete _graphics_ es posible crear ejes de una forma mucho más personalizada. Por ello, para crear el eje X utilizamos dicha función, situándolo en la parte superior ( __side = 3__ ). Por otra parte, para denotar la posición en el eje X donde debe situarse cada número de semana, mediante la función _Reduce_ calculamos la distancia de separación entre cada conjunto de barras apiladas, en base al ancho y espacio establecidos por parámetro. Finalmente, coloreamos de azul el eje mediante el parámetro _col.axis_.

```
pos_inicial <- ancho / 2 + espacio
longitud <- length(colnames(matriz)) - 1
v <- Reduce(function(v, x) v + 2 * ancho / 2 + espacio, x=numeric(longitud),  
            init=pos_inicial, accumulate=TRUE)
axis(side = 3, at = v, colnames(matriz), col.axis = "blue", font = 2, tick = FALSE)
```

3. __Los números de modalidad deben estar a la izquierda, en azul. Agrega un título al gráfico__. De forma similar al eje X, mediante la función _axis_ creamos el eje Y ( __side = 2__ ). Para denotar la posición donde debe situarse cada modalidad, nuevamente mediante una función _Reduce_ calculamos la distancia de separación entre cada valor (dado que en el eje Y no existe separación entre barras, sólo se tiene en cuenta el ancho). Finalmente, mediante la función _title_ añadimos un título al gráfico, situándolo en la parte superior ( __line = 3__ ), así como una leyenda en la parte superior derecha:

```
pos_inicial_2 <- ancho / 2
longitud_2 <- length(row.names(matriz)) / 2 - 1
w <- Reduce(function(w, x) w + 2 * pos_inicial_2, x=numeric(longitud_2),
            init=pos_inicial_2, accumulate=TRUE)
axis(side = 2, at = w, row.names(matriz)[seq(1,length(row.names(matriz)),2)], 
     col.axis = "blue", cex = 125, font = 2, tick = FALSE)

title("FRECUENCIAS DE ARDOR DE HIDROGEL - SEMANAS 1 A LA 7", line = 4, cex.main = 1.25)
legend(x= "topright",  legend = c("FREC. ARDOR", "FREC. SIN ARDOR"), 
       inset = c(-0.2, 0), fill = c("red", "white"), 
       cex = 0.6, text.font = 2, bg = 'white')
```

Si nos fijamos en la función _axis_ podemos observar que, del conjunto de nombres de fila que previamente hemos asociado a la matriz:

$$(1, 1 - f_1, 2, 1 - f_2, 3, 1 - f_3, 4, 1 - f_4)$$
Sólo extraemos aquellos situados en las posiciones impares, esto es, __los números de modalidad__:

```
row.names(matriz)[seq(1,length(row.names(matriz)),2)]
```

Una vez creada la función, realizamos la prueba final, empleando como ancho de barra 1 y espacio 0.2 entre barra y barra (eje X):

```{r prueba_mostrar_frecuencias, fig.width=7, fig.height=6, fig.cap="Gráfico de barras con la evolución de sensación de ardor con el tiempo (II)"}
mostrar_frecuencias(matriz.frecuencias, 1, 0.2)
```